# 基础

## 引用

在python中引用就是变量的地址。因为变量存储的就是引用的地址。

变量位于栈内存中，对象位于堆内存中。

python是动态类型语言，变量不需要显式声明类型；同时python也是强类型语言，每个对象都有数据类型，只支持该类型支持的操作。

变量在使用前必须被初始化(赋值)。

## 删除变量和垃圾回收

使用**del**删除不使用的变量。

对象不被引用时就会被垃圾回收器回收。

## 链式赋值

把同一对象赋值给多个变量：

```pythnn
x=y=123
```

;

## 系列解包赋值

系列数据赋值给对应相同个数的变量

a,b=1,2 相当于a=1,b=2

## 常量

python不支持常量，只能通过逻辑约定。

## 最基本的内置数据类型

整型，浮点型，布尔型、字符串型

### 数字型的运算

+、-、*，/，//（整数除法）、%(模，取余)、**(幂)

0 不能作为除数

`divmode`() 函数可以同时得到商和余数：

```python
>>>divmode(13,3)
(4,3) #的到一个元组
```

### 整数

python中除了10进制外，还有其他三种进制：

 	- 0b或者0B，二进制0 1
 	- 0o或者0B，八进制0 1 2 3 4 5 6 7
 	- 0x或者0X，十六进制0 1 2 ... 9 a b c d e f

这三种进制都可以方便的进行“位运算”操作

```python
>>> 12
12
>>> 0b101
5
>>> 0o10
8
>>> 0xff
255
```

#### 使用`int()`实现类型转换

- 1.浮点数直接舍弃小数部分。

- 2.布尔值 True 转化为1，False转化为0。

- 3.字符串符合整数类型(浮点格式不行),则直接转成整数，否则报错。

#### 自动转型

整数和浮点数混合运算时，表达式结果自动转型成为浮点数。

### 浮点数

`round(value)`可以返回四舍五入的值

​	注：但不会改变原有的值，而是产生新的值。

### 增强型赋值运算符

运算符+、-、*、/、//、**、%和赋值符=可以构成“增强型赋值运算符”。

### 时间

python中通过`time.time()`获得当前时刻，返回的值是以秒为单位，带微秒(1/1000毫秒)精度的浮点值。

### 布尔值

python3中True和False 实际上还是0和1，可以和数字一起运算

### 逻辑运算符

or,and,not(或，与，非)

### 同一运算符

同一运算符用于比较两个对象的存储单元，实际上比较的是对象的地址。

is 和 == 的区别：

	- is 用于判断两个变量引用对象是否为同一个，即比较**对象的地址**。
	-  == 用于判断引用变量引用**对象的值** 是否相等，默认调用对象的 `__eq__()`方法。

- **整数缓存问题**
  
- python对比较小的对象进行缓存[-5,256]，在 Pycharm 或者保存为文件时，解释器做了一部分优化[-5,任意整数]。
  
- is 运算符比 == 效率高，在变量和 None 进行比较时，应该使用 is。

  ## 字符串

  python中字符串是不可变的。

  ### 字符串的编码

  使用内置函数 `ord()` 可以把字符串转换成对应的 Unicode 码；

  使用内置函数 `char()` 可以把十进制数字转换成对应的字符。

  ```python
  >>> ord('A')
  65
  >>> char(66)
  'B'
  ```

  连续三个单引号或双引号，可以创建多行字符串：

  ```python
  >>>resume = '''name = "dengjiaqi"
   company = "gxu" age = 26'''
  >>>print(resume)
  name = "dengjiaqi"
   company = "gxu" age = 26
  ```

  python中允许空字符串存在，不包含任何字符且长度为0。例：

  ```python
  >>> c = ''
  >>> len(c)
  0
  ```

  `len()` 用于计算字符串含有多少个字符。

###  转义字符

`\`(在行尾时）：续行符

`\\` :反斜杠符号

`\'`:单引号

`\"`:双引号

`\b`：退格（backspace）

`\n`：`换行`

`\t`:横向制表符

`\r`:回车

### 字符串拼接

- 可以使用 + 将多个字符串拼接起来。

  - `+`两边都是字符串，则拼接。
  - `+`两边都是数字，则加法运算。
  - `+`两边类型不同，则抛出异常。

- 可以将多个字面字符串直接放到一起实现拼接：

  `’aa‘ 'bb' == > 'aabb'`

### 字符串复制

可以使用 * 实现字符串复制：

```python
>>> a = 'deng'*3
>>> a
'dengdengdeng'
```

### 不换行打印

通过参数 `end = "任意字符串"` ,实现末尾添加任何内容。

```python 
>>> print("aa",end="*")
>>> print("bb")
"aa*bb"
```

### 从控制台读取字符串

使用 `input()` 从控制台读取键盘输入的内容

### `str()` 实现数字转型字符串

`str()` 可以帮助我们将其他数据类型转换成字符串，例如：

`str(5.20) ==> '5.20'`

当我们调用 print() 函数时，解释器自动调用了 `str()` 将非字符串对象转换成了字符串。

### 使用 [] 提取字符串

在[] 里指定偏移量，可以提取该位置的单个字符。

### 使用replace() 实现字符串替换

```python 
>>> a = 'abcdefg'
>>> a
'abcdefg'
>>> a.repalce('c','h')
>>> a
'abhdefg'
```

整个过程实际上我们是创建了新的字符串对象，并指向了变量a ,而不是修改了以前的字符串。

### 字符串切片slice操作

[起始偏移量start：中止偏移量end：步长step]``

- 典型操作：
  - [:] : 提取整个字符串
  - [start:] : 从start索引开始到结尾
  - [: end] : 从开头直到 end - 1
  - [start : end] : 从start 到 end -1

- 操作数为负：
  - [-3:] : 导数第三个
  - [-8:-3] : 倒数第八个到导数第三个(包头不包尾)
  - [::-1] : 步长为负，从右到左反向提取

切片时，起始偏移量和中止偏移量不再[0 : 字符串长度-1]这个范围内，也不会报错。起始偏移量小于0 则会被当做 0 .中止偏移量大于“长度-1”会被当成 -1。

### `splite()` 分割和 `join()` 合并

`splite()` 可以基于指定分割符将字符出啊分隔成多个子字符串，如果不指定分隔符，则默认使用空白字符(换行符/空格/制表符)：

```python
>>> a = "to be or not to be"
>>> a.split()
['to','be','or','not','to','be']
```

join() 的作用和 split()的作用刚好相反，用于将一系列子字符串连接起来。

##### 拼接字符串要点

在使用字符串拼接符 + ，会生成新的字符串对象，因此不推荐使用 +来拼接字符串，推荐使用join 函数，因为 join 函数在拼接字符串之前会计算所有字符串的长度，然后逐一拷贝，仅新建一次对象。

### 字符串驻留机制和字符串比较

#### 字符串驻留

仅保存一份相同且不可变字符串的方法，不同的值被存放到字符串驻留池中。python支持字符串驻留机制，对于符合标识符规则的字符串(仅包含下划线 （_）、字母和数字)会启用字符串驻留机制。

```python
>>> a = 'abc_123'
>>> b = 'abc_123'
>>> a is b
True
```

### 成员操作符

`in / not in` 关键字，判断某个字符(子字符串)是否存在于字符串中。

### 字符串其他常用方法

#### 常用查找方法

`a.startswith('aa')` ：以指定字符串开头。（True/False）

`a.endswith("bb")`：以指定字符串结尾。（True/False）

`a.find('a')`：第一次出现指定字符串的位置。

`a.rfind('b')`：最后一次出现指定字符串的位置。

`a.count('haa')`：指定字符出现了几次。

`a.isalnum()`：所有字符全是字母或数字。(True/False)

#### 去除首尾信息

strip() 去除字符串首尾指定信息。通过 `lstrip()` 去除字符串左边指定信息，`rstrip()` 去除字符串右边指定信息。

#### 大小写转换

`a.capitalize()`：产生新的字符串，首字母大写。

`a.title()`：产生新的字符串，每个单词都首字母大写。

`a.upper()`：产生新的字符串，所有字符全部转成大写。

`a.lower()` ：产生新的字符串，所有字符全部转换成小写。

`a.swapcase()`：产生新的，所有字母大小写转换。

#### 格式排版

`center() 、ljust()、rjust()` 这三个函数用于对字符串实现排版。如：

```python
>>> a = 'deng'
>>> print(a.center(12, "-"))
>>> print(a.ljust(12,"&"))
>>> print(a.rjust(12,"%"))
"----deng----"
"deng&&&&&&&&"
"%%%%%%%%deng"
```

#### 其他方法

- `isalpha()` :检测字符串是否只由字母组成（含汉字）。
- `isdigit()`：检测字符串知否只由数字组成。
- `isspace()`：检测是否为空白符（制表符/换行符/空格）。
- `isupper()`：检测是否为大写字母。
- `islower()`：检测是否为小写字母。

### 字符串格式化

`str.format()` : 基本语法是通过{} 和 : 来代替以前的 %。

```python
>>> a = "名字是：{0}，年龄是{1}。"
>>> a.format("张三",18)
名字是:张三，年龄是18。
>>> c ="名字是：{name}，年龄是{age}。"
>>> c.format(age=20,name="李四")
名字是:李四，年龄是20。
```

我们可以通过 {索引}/{参数名}，直接映射参数值，实现对字符串的格式化。

# 序列

序列是一种数据存储方式，用来存储一系列的数据。在内存中，序列就是**一块用来存放多个值的连续的内存空间** 。

序列中存储的是整数对象的地址，而不是整数对象的值。python中常用的序列结构有：

**字符串、列表、元组、字典、集合**

## 列表

**列表** ： 用于存储任意数目、任意类型的数据集合。

列表是内置可变序列，是包含多个元素的有序连续的内存空间。列表定义的标准语法格式：

​											`a = [10,20,30,40]`

其中，10，20这些可以称为：列表 a 的元素。

列表中的元素可以各不相同，可以是任意类型。

### 列表常用方法

- `list.append(x)` ：将元素x添加到列表 list 的尾部。
- `list.extend(alist)`：将列表 alist 所有元素加到列表 list 尾部。
- `list.insert(index,x)`：在列表 list 指定位置 index 处插入元素 x。
- `list.remove(x)`：在列表 list 中删除首次出现的指定元素 x。
- `list.pop([index])`：删除并返回列表 list 指定为止 index 处的元素，默认是最后一个元素。
- `list.clear()`：`删除列表所有元素`，并不是删除列表对象。
- `list.index(x)`返回第一个 x 的索引位置，若不存在 x 元素抛出异常。
- `list.count(x)`：返回指定元素 x 在列表 list 中出现的次数。
- `len(list)`：返回列表中包含元素的个数。
- `list.remove()` :所有元素原地翻转。
- `list.sort()`：所有元素原地排序。
- `list.copy()`：返回列表对象的浅拷贝。

python列表大小可变，根据需要随时增加或缩小。

### 列表对象的创建

#### 基本语法 [] 创建

```python
>>> a = [10,20,30]
>>> a = [] #创建空列表
```

#### list() 创建

使用 list() 可以将任何**可迭代数据**转化成列表。

```python
>>> a = list(range(10))
>>> a
[0,1,2,3,4,5,6,7,8,9]
>>> b = list() #创建空列表
```

#### range() 创建整数列表

`range([start,] end [,step])`

python3 中 range() 返回的是一个 range 对象，而不是列表，我们需要通过 list() 方法将其转换成列表对象。

```python
>>> a = list(range(20,2,-2))   #倒数
>>> a
[20, 18, 16, 14, 12, 10, 8, 6, 4]
```

#### 列表推导式

```python 
>>> a = [x**2 for x in range(10)]
>>> a
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
```

### 列表元素的增加

当列表增加和删除元素时，列表会自动进行内存管理，但这个特点涉及列表元素的大量移动，效率较低，除非必要，我们一般只在列表的尾部添加元素或删除元素，这样会大大提高列表的操作效率。

#### append() 方法

原地修改列表，是真正的列表尾部添加新的元素，速度最快。

```python
>>> a = [10,20]
>>> a.append(99)
>>> a
[10,20,99]
```

#### + 运算符

并不是真正的尾部添加元素，而是创建新的列表对象；将原列表的元素和新列表的元素依次复制到新的列表对象中。这样会涉及大量的复制操作，对于操作大量元素不建议使用。

```python
>>> a = [10,20]
>>> a = a + [99]
>>> a
[10,20,99]
```

#### extend() 方法

将目标列表的所有元素添加到本列表的尾部，属于原地操作，不创建新的列表对象。

将两个列表合并时，推荐使用该方法。

#### insert() 插入元素

使用 insert() 方法可以将指定元素插入到列表对象的任意指定为止。这样会让插入位置后面的元素进行移动，会影响处理速度。涉及大量元素时，尽量避免使用。类似发生这样移动的函数还有：`remove()、pop()、del()`它们在删除非尾部元素时也会发生操作位置后面元素的移动。

```python
>>> b = list(range(10))
>>> b.insert(2,-99)
>>> b
[0, 1, 2, -99, 3, 4, 5, 6, 7, 8, 9]
```

####　乘法扩展

适用于乘法操作的还有:字符串、元组。

```python
>>> a = ['sxt',100]
>>> b = a*3
>>> b
['sxt', 100, 'sxt', 100, 'sxt', 100]
```

### 列表元素的删除(本质是数组的拷贝)

#### del 删除

删除列表指定位置的元素。

```python
>>> a = ['sxt',100]
>>> b = a*3
>>> del b[1]
>>> b
['sxt', 'sxt', 100, 'sxt', 100]
```

#### pop() 方法

pop() 删除并返回指定位置元素，如果未指定位置则默认操作列表最后一个元素。

```python
>>> b.pop()
100
>>> b
['sxt', 'sxt', 100, 'sxt']
```

#### remove() 方法

删除首次出现的指定元素，若不存在该元素则抛出异常。

### 列表元素的访问和计数

#### 通过索引直接访问元素

可以通过索引直接访问元素。索引的区间在 [0，列表长度-1] 这个范围。超过这个范围则会抛出异常。

```python
>>> a = list(range(0,100,10))
>>> a[2]
20
```

#### index() 获得指定元素在列表中首次出现的索引

index() 可以获取指定元素首次出现的索引位置。语法是：`index(value,[start,[end]])`。其中，start 和 end 制定了搜索的范围。

```python
>>> a.index(20)
2
>>> a = [10,20,30,40,50,20,30,20,30]
>>> a.index(20,3) #从索引位置3开始往后搜索的第一个20
5
```

#### count() 获得指定元素在列表中出现的次数

count() 可以返回指定元素在列表中出现的次数

```python
>>> a.count(20)
3
```

#### len() 返回列表长度

len() 返回列表长度，即列表中包含的元素的个数。

#### 成员资格判断

判断列表中是否存在指定的元素，可以用 count() 方法，返回 0 则表示不存在，返回大于 0 的则表示存在。但一般我们会使用 in 关键字来判断，直接返回 True 或者 False。

### 切片操作

与字符串切片差不多。

### 列表排序

#### 修改原序列,不建新列表的排序。

```python
>>> a.sort() #默认是升序排列
>>> a.sort(reverse=True) #降序排列
>>> random.shuffle(a) #打乱
```

#### 建新列表的排序

可以通过内置函数 `sorted()` 进行排序，这个方法返回新列表，不对原列表做修改。

```python 
>>> sorted(a)  #默认升序
```

####　reversed() 返回迭代器

内置函数 reversed() 也支持逆序排列，但是与列表对象 reverse() 方法不同的是内置函数reversed() 不对原列表做任何修改，只是返回一个逆序排列的迭代器对象。

```python
a = list(range(10))
b = reversed(a)
print(b)
<list_reverseiterator object at 0x0000027E10863BA8>
print(list(b))
[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
```

#### sum 求和

对数值型列表的所有元素进行求和操作，对非数值型列表运算则会报错。

### 多维列表

#### 二维列表

`[[1,2],['aa','aaa'],['bbb','cc','dd']]`

## 元组

元组属于不可变序列，不能修改元组中的元素。因此，元组没有增加元素、修改元素、删除元素相关方法。

元组支持的操作如下：

- 索引访问
- 切片操作
- 连接操作
- 成员关系操作
- 比较运算操作
- 计数：元组长度 len() 、最大值 max() 、最小值 min() 、求和 sum() 等。

### 元组的创建

#### 通过() 创建元组，小括号可以省略

如果元组只有一个元素，那必须在后面加逗号。因为解释器会把（1）解释为整数1，把（1，）解释为元组。

#### 通过 tuple() 创建元组

`tuple(可迭代的对象)`

总结：

- tuple() 可以接收列表、字符串、其他序列对象，迭代器等生成元组。
- list() 可以接收元组、字符串、其他序列类型、迭代器等生成列表。

#### 元组的删除

`del a  #删除元组a`

### 元组的元素访问和计数

1.元组的元素不能修改

2.元组的元素访问和列表一样，只不过返回的仍然是元组

3.列表关于排序方法 list.sorted() 是修改原列表对象，元组没有该方法。如果要对元组排序，只能使用内置函数 **sorted(tupleObj)** ，并生成新的列表对象。

### zip

`zip(列表1，列表2，...)` 将多个列表对应位置的元素组合成为元组，并返回这个 zip 对象。

```python
>>> a = [1,2,3]
>>> b = [10,20,30]
>>> c = [100,200,300]
>>> d = zip(a, b, c)
>>> list(d)
[(1, 10, 100), (2, 20, 200), (3, 30, 300)]
```

### 生成器推导式创建元组

从形式上看，生成器推导式与列表推导式类似，只是生成器推导式使用小括号。列表推导式直接生成列表对象，生成器推导式生成的**既不是列表也不是元组**，而是一个**生成器对象**。

可以通过生成器对象，转化成列表或者元组，也可以使用生成器对象的`__next__()`方法进行遍历，或者直接作为迭代对象来使用，不管什么方式使用，元素访问结束后，如果需要重新访问其中的元素，必须重新创建该生成器对象。

```python
>>> a = (x**2 for x in range(10))
>>> a
<generator object <genexpr> at 0x000001D1F2C4AA98>
>>> tuple(a)
(0, 1, 4, 9, 16, 25, 36, 49, 64, 81)
>>> a.__next__()
0
>>> a.__next__()
1
>>> list(a)   #只能访问一次元素，第二次就为空了，需要再生成一次
[]
```

### 元组总结

- 1.元组的核心特点是：不可变序列
- 2.元组的访问和处理速度比列表快
- 与整数和字符串一样，元组可以作为字典的键，列表则永远不能作为字典的键使用。

# 字典

​		字典是“键值对”的无序可变序列，字典中的每个元素都是一个“键值对，包含：”键对象“和”值对象“。可以通过”键对象“实现快速获取、删除、更新对应的”值对象“。

​		列表中我们通过”下标数字“找到对应的对象。字典中通过”键对象“找到对应的”值对象“。”键“是任意的不可变数据，如：整数、浮点数、字符串、元组。但是：列表、字典、集合这些可变对象，不能作为”键“。并且”键“不可重复。

## 字典的创建

#### 1.可以通过 {} , dict() 来创建字典对象。

```python
>>> a = {'name':'张三','age':19}
>>> b = dict([('name','张三'),('age',19)])
```

#### 2.可以通过 zip() 创建字典对象

```python
>>> k = ['name','age']
>>> l = ['张三',19]
>>> d = dict(zip(k,l))
{'name': '张三', 'age': 19}
```

#### 3.通过fromkeys 创建值为空的对象

```python
>>> a = dict.fromkeys(['name','age','job'])
>>> a
{'name': None, 'age': None, 'job': None}
```

## 字典元素的访问

`a = {'name':'张三','age':19,'job':'python'}`

#### 1.通过 [键] 获得 “值”。若键不存在，则抛出异常

```python
>>> a['name']
'张三'
```

#### 2.通过 get() 方法获得“值”,推荐使用。优点是：指定键不存在，返回None；也可以设定指定键不存在时默认返回的对象。推荐使用 get() 获得 “值对象”。

```python
>>> a.get('age')
19
>>> a.get('sex','不存在')
'不存在'
```

#### 3.列出所有的键值对

```python
>>> a.items()
dict_items([('name', '张三'), ('age', 19), ('job', 'python')])
```

#### 4.列出所有的键，列出所有的值

```python
>>> a.keys()
dict_keys(['name', 'age', 'job'])
>>> a.values()
dict_values(['张三', 19, 'python'])
```

#### 5.len() 键值对的个数

#### 6.检测一个“键”是否在字典中

```python
>>> 'name' in a
True
```

### 字典元素添加、修改和删除

1.给字典新增“键值对”，如果“键”已经存在，则覆盖旧的键值对；如果“键”不存在，则新增“键值对”。

```python
>>> a['address'] = 'china'
>>> a
{'name': '张三', 'age': 19, 'job': 'python', 'address': 'china'}
```

2.使用 update() 将新字典中所有键值对全部添加到旧字典对象上。如果 key 有重复，则直接覆盖。

```python
>>> b = {'name':'李四', 'salary':20000, 'sex':'男'}
>>> a.update(b)
>>> a
{'name': '李四', 'age': 19, 'job': 'python', 'address': 'china', 'salary': 20000, 'sex': '男'}
```

3.字典中元素的删除，可以使用 `del()` 方法；或者 `clear()` 删除所有的键值对；`pop()` 删除指定键值对，并返回对应的“值对象”；

```python
>>> del(a['sex'])
>>> a
{'name': '李四', 'age': 19, 'job': 'python', 'address': 'china', 'salary': 20000}
>>> c = a.pop('address')
>>> c
'china'
>>> a.clear()
>>> a
{}
```

4. `popitem()`:随即删除和返回该键值对。字典是“无序可变序列”,因此没有一个元素、最后一个元素的概念；popitem 弹出随机的项，因为字典并没有“最后的元素”或者其他有关顺序的概念。若想一个接一个地移除并处理项，这个方法就非常有效（因为不用首先获取键的列表）。

```python
>>> a = {'name':'张三','age':19,'job':'python'}
>>> a.popitem()
('job', 'python')
>>> a.popitem()
('age', 19)
```

### 序列解包

序列解包可以用于元组、列表、字典。序列解包可以方便的**对多个变量赋值**。

```python
>>> x, y, z = (10, 20, 30)
>> x
10
>> y
20
>>>(x,y,z) = (100,200,300)
>> x
100
```

序列解包用于字典时，默认是对“键”进行操作；如果需要对键值对操作，则需要使用 `items()`；如果需要对“值” 进行操作，则需要使用 `values()`；

```python
>>> a = {'name':'张三','age':19,'job':'python'}
>>> name,age,job = a
>>> name
"张三"
>>> name,age,job = a.items()  #对键值对进行操作
>>> age
('age', 19)
>>>name,age,job = a.values()  #对值进行操作
>>> job
'python'
```

### 字典核心底层原理（重要）

​		字典对象的核心是散列表。散列表是一个稀疏数组(总是有空白元素的数组),数组的每个单元叫做 bucket。每个bucket 有两部分：一个是键对象的引用，一个是值对象的引用。

​		由于所有的bucket结构和大小一致，我们可以通过偏移量来读取指定的bucket。

### 用法总结

1.键必须可散列：

- 数字、字符串、元组等，都是可散列的。
- 自定义对象需要支持下面三点
  - 支持 `hash()` 函数。
  - 支持通过 `__eq()__`方法检测相等性。
  - 若 `a == b`为真，则 `hash(a) == hash(b)` 也为真。

2.字典在内存中开销巨大，典型的空间换时间。

3.键查询速度很快。

4.往字典里添加新建可能导致扩容，导致散列表中建的次序变化。因此，不要遍历字典的同时进行字典的修改。

# 集合

集合是无序可变，元素不能重复。实际上，集合底层是字典实现的，集合的所有元素都是字典中的“键对象”，因此是不能重复且唯一的。

## 集合创建和删除

1.使用 {} 创建集合对象，并使用 add() 方法添加元素。

```python
>>> a = {1,2,3}
>>> a
{1,2,3}
>>> a.add(4)
>>> a
{1,2,3,4}
```

2.使用 set() ，将列表，元组等可迭代对象转成集合。如果原来的数据存在重复数据，则只保留一个。

```python
>>> b = set([1,2,2,3,4,5,6,3])
>>> b
{1, 2, 3, 4, 5, 6}
```

3.remove() 删除指定元素；clear() 清空整个集合。

## 集合相关操作

python集合也提供了并(`|，a.union(b)`)、交(`&,a.intersection(b)`)，差(`-，a.difference(b)`)等集合运算。

# 控制语句

## 选择结构

选择结构通过判断条件是否成立，来决定执行哪个分支。选择结构有多种形式，分为：单分支、双分支、多分支。

### 单分支选择结构：

if 语句单分支结构的语法形式如下：

```python
if 条件表达式：
	语句/语句块
```

其中：

	- 条件表达式：可以是逻辑表达式、关系表达式、算术表达式等。
	- 语句/语句块：可以是一条语句，也可以是多条语句。多条语句，缩进必须对齐一致。

#### 条件表达式详解：

在选择和循环结构中，条件表示式的值为 False 的情况如下：

​	False、0、0.0、空值 None、空序列对象（空列表、空元组、空集合、空字典、空字符串）、空range对象、空迭代对象。

其他情况均为 True。在python中所有的合法表达式都可以看做条件表达式，甚至包括函数调用的表达式。

- **条件表达式中不能有赋值操作符“=”**

### 双分支选择结构：

双分支结构的语法格式如下：

```python
if 条件表达式：
	语句1/语句块1
else:
    语句2/语句块2
```

#### 三元表达式

```python
条件为真时的值 if (条件表达式) else 条件为假时的值
```

### 多分支选择结构

多分支选择结构如下：

```python
if 条件表达式1：
	语句1/语句块1
elif 条件表达式2：
	语句2/语句块2
    ...
elif 条件表示式n:
    语句n/语句块n
[else:
    语句n+1/语句块n+1]
```

## 循环结构

​		循环结构用来重复执行一条或多条语句。表达这样的逻辑：如果符合条件，则反复执行循环体里的语句。在每次执行完后都会判断一次条件是否 True,如果为True则重复执行循环体里的语句。

​		循环体里面的语句至少应该包含改变条件表达式的语句，以使循环结束；否则，就是一个死循环。

###　while 循环

```python 
while 条件表达式：
	循环体语句
```

### for循环和可迭代对象遍历

for 循环常用于可迭代对象的遍历。语法格式如下：

```python
for 变量 in 可迭代对象：
	循环体语句
```

#### 可迭代对象

python 包含以下几种可迭代对象：

- 序列：字符串、列表、元组
- 字典
- 迭代器对象（iteratior）
- 生成器函数（generator）

### range对象

range 对象是一个迭代器对象，用来产生指定范围内的熟悉序列。格式为：

```python 
range(start,end [,step])
```

​		生成的数值序列从 start 开始到 end 结束（不包含 end）。若没有填写 start,则默认从0开始，step 是可选的步长，默认为1。

### 嵌套循环

一个循环体内可以嵌入另一个循环，一般称为“嵌套循环”或者”多重循环“。

### break语句

​		break 语句可用于while 和 for 循环，用来结束整个循环。当有嵌套循环时，break 语句只能跳出最近一层的循环。

### continue 循环

continue 语句用于结束本次循环，继续下一次，多个循环嵌套时，continue 也是应用于最近一层的循环。

## 变量的作用域（全局变量和局部变量）

​		变量起作用的范围成为变量的作用域，不同作用域内同名变量之间互不影响。变量分为：全局变量、局部变量。

**全局变量**：

​		1.在函数和类定义之外声明的变量。作用域为定义的模块，从定义位置开始直到模块结束。

​		2.全局变量降低了函数的通用性和可读性。应尽量避免全局变量。

​		3.全局变量一般做常量使用。

​		4.函数内要改变全局变量的值，使用 global 声明一下。

**局部变量**：

​		1.在函数体中(包含形式参数)声明的变量。

​		2.局部变量的引用比全局变量快，优先考虑使用。

​		3.如果局部变量和全局变量同名，而在函数内隐藏全局变量，只使用同名的局部变量。

```python
>>>locals()  #显示局部变量
>>>globals() #显示全局变量
```

局部变量的查询和访问速度比全局变量要快，优先考虑使用，尤其是在循环的时候。

### 参数的传递

​		函数的参数传递本质上就是：从实参到形参的赋值操作。python中“一切皆对象”,所有的赋值操作都是“引用的赋值”,所以，python中参数的传递都是“引用传递”，不是“值传递”。具体操作时分为两类：

​		1.对“可变对象”进行写操作，直接作用于原对象本身。

​		2.对“不可变对象”进行“写操作”，会产生一个新的“对象空间”,并引用新的值填充这块空间。(起到其他语言的“值传递”效果，但不是“值传递”)。



可变对象有：字典、列表、集合、自定义的对象等。

不可变对象有：数字、字符串、元组、function等。

#### 传递可变对象的引用

​		传递参数是可变对象，实际传递的还是对象的引用，在函数体中不创建新的对象拷贝，而是可以直接修改所传递的对象。

```python
b = [100, 200]
def f2(m):
    print("m:", id(m))
    m.append(30)
f2(b)
print("b:", id(b))
print(b)

m: 2154969129544
b: 2154969129544
[100, 200, 30]
```

#### 传递不可变对象的引用

​		传递参数是不可变对象（如 int、float、字符串、元组、布尔值），实际传递的还是对象的引用。在“赋值操作”时，由于不可变对象无法修改，系统会新创建一个对象。

```python
a = 100
def f1(n):
    print("n:",id(n))   #传递进来的是a对象的地址
    n += 200			#由于a是不可变对象，因此创建新的对象n
    print("n:",id(n))   #n已经变成了新的对象
    print(n)
f1(a)
print("a:",id(a))

n: 140713445728160
n: 2458818835888
300
a: 140713445728160
```

### 浅拷贝和深拷贝

copy（浅拷贝）、deepcpoy（深拷贝）

浅拷贝：不拷贝子对象的内容，只是拷贝子对象的引用。

深拷贝：会连子对象的内存也全部拷贝一份，对子对象的修改不会影响原对象。

```python
import copy

a = [10, 20, [5, 6]]
b = copy.copy(a)

print("a:", a)
print("b:", b)

b.append(30)
b[2].append(7)

print("浅拷贝----")
print("a:", a)
print("b:", b)


a: [10, 20, [5, 6]]
b: [10, 20, [5, 6]]
浅拷贝----
a: [10, 20, [5, 6, 7]]
b: [10, 20, [5, 6, 7], 30]
```

### 参数的几种类型

#### 位置参数

​		函数调用时，实参默认按位置顺序传递，需要个数和形参匹配。按位置传递的参数，我们称之为“**位置参数**”。

```python
def f1(a, b, c):
    print(a,b,c)
f1(1,2,3)
1 2 3
f1(1,2) #报错，位置参数不匹配
```

#### 默认值参数

​		可以为某些参数设置默认值，这样这些参数在传递时就是可选的，称为“默认值参数”。**默认值参数放到位置参数后面**。

```python
def f1(a, b, c=10, d=20):
    print(a,b,c,d)
```

#### 命名参数

我们也可以按照形参的名称传递参数，称为“命名参数”，也称“关键字参数”。

#### 可变参数

可变参数指的是“可变数量的参数”。分为两种情况：

1.`*param`（一个星号），将多个参数收集到一个“元组”对象中。

2.`**param`（两个星号），将多个参数收集到一个“字典”对象中。

```python
def f2(a, b, *c):
    print(a, b, c)

f2(1,2,3,4)
1 2 (3,4)

def f3(a, b, **c):
    print(a, b, c)

f3(8, 9, name='张三', age=18)
8 9 {'name': '张三', 'age': 18}
```



#### 强制命名参数

在带星号的“可变参数”后面增加新的参数，必须是“强制命名参数”。

```python
def f1(*a, b, c):
    print(a, b, c)
    
f1(1, 2, b=3, c=4)

(1,2) 3 4
```

## lambda表达式和匿名函数

​		lambda表达式可以用来声明匿名函数，lambda函数是一种简单的，在同一行中定义函数的方法。lambda函数实际生成了一个函数对象。

​		lambda表达式只允许包含一个表达式，不能包含复杂语句，该表达式的计算结果就是函数的返回值。

​		lambda 表达式的基本语法如下：

```python
lambda arg1, arg2, arg3, ... : <表达式>
```

​		arg1, arg2, arg3为函数的参数。<表达式>相当于函数体。运算结果是：表达式的运算结果。

```python
f = lambda a,b,c : a+b+c
print(f)
print(f(2,3,4))
<function <lambda> at 0x000001F718EDD048>
9
```

### `eval()` 函数

功能：将字符串 `str` 当成有效的表达式来求值并返回计算结果。

语法：`eval(source[,globals[,locals]]) -> value`

参数：

​		`source`：一个python表达式或函数 compile() 返回的代码对象。

​		`globals` :可选，必须是 dictionary。

​		`locals`:可选。任意映射对象。

```python 
eval("print('abcde')")
abcde

dict1 = dict(a=100,b=200)
d = eval("a+b",dict1)
print(d)
300
```

## 递归函数

​		递归函数指的是：自己调用自己的函数，在函数体内部直接或间接地自己调用自己。递归类似于大家中学数学学习过的“数学归纳法”，每个递归函数必须包含两个部分：

- 终止条件

  ​	表示递归什么时候结束。一般用于返回值，不再调用自己。

- 递归步骤

  ​	把第 n 步的值和第 n-1 步相关联。

递归函数由于会创建大量的函数对象，过量的消耗内存和运算能力。在处理大量数据时，谨慎使用。

```python
def factorial(n):
    if n == 1:
        return 1
    return n*factorial(n-1)

for i in range(1,6):
    print(i, "!=", factorial(i))
    
1 != 1
2 != 2
3 != 6
4 != 24
5 != 120
```

### 嵌套函数（内部函数）

嵌套函数：在函数内部定义的函数！

```python
def outer():
    print("outer running ...")
    def inner():
        print('inner running ...')
    inner()
outer()
outer running ...
inner running ...
```

一般什么情况下使用嵌套函数？

- 封装 - 数据隐藏

  ​	外部无法访问“嵌套函数”

- 贯彻 DRY（don't repeat yourself）原则

  ​	嵌套函数可以让我们在函数内部避免重复代码

- 闭包

## nonlocal 关键字

nonlocal 用来声明外层的全局变量

global 	用来声明全局变量

```python
def outer():
    b = 10

    def inner():
        nonlocal b  # 声明外部函数的局部变量
        print("inner b:", b)
        b = 20
    inner()
    print("outer b:", b)

outer()

inner b: 10
outer b: 20
```

## LEGB 规则

​		python在查找“名称”时，是按照LEGB规则查找的：Local --> Enclosed --> Global --> Built in。

- Local		指的就是函数或者类的方法内部
- Enclosed  指的是嵌套函数（一个函数包裹另一个函数，闭包）
- Global       指的是模块中的全局变量
- Built in       指的是python为自己保留的特殊名称

如果某个 name 映射在局部（local）命名空间中没有找到，接下来就会在闭包作用域（enclosed）进行搜索，如果闭包作用域也没有找到，python就会到全局（global）命名空间中进行查找，最后会在内建（built-in）命名空间搜索（如果一个名称在所有的命名空间中都没有找到，就会产生一个NameError）。

```python
#str()                    #built-in
#str = "global str"       #global
def outer():

    #str = "outer str"     #enclosed
    def inner():
        #str = "inner str" #local
        print(str)

    inner()

outer()
```

# 面向对象编程

## 类的定义

定义类的语法格式：

```
class 类名：
	类体
```

要点如下：

​	1.类体中我们可以定义属性和方法

​	2.属性用来描述数据，方法（即函数）用来描述这些数据相关的操作

```python
class Student:
    def __init__(self, name, score):   # 构造方法的第一个参数必须是self
        self.name = name               # 实例属性
        self.score = score

    def say_score(self):                # 实例方法
        print(self.name, "的分数是：", self.score)


s1 = Student("张三", 88)            #默认自动调用构造方法 __init()__
s1.say_score()
```

### 构造函数 `__init__()`

​		类是抽象的，也称之为“对象的模板”。我们需要通过类这个模板，创建类的实例对象，然后才能使用类定义的功能。

​		我们之前说过一个python对象包含三个部分：id(identity识别码)、type(对象类型)、value(对象的值)。

现在我们可以更近以部的讲一个python对象包含如下部分：

  - id(identity识别码)

  - type(对象类型)

  - value(对象的值)

    ​	1.属性（attribute）

    ​	2.方法（method）

创建对象，我们需要定义构造函数 `__init__()` 方法。构造方法用于执行“实例对象的初始化工作”,即对象创建后，初始化当前对象的相关属性，无返回值。

`__init__()`的要点如下：

- 名称固定，必须为 `__init__()`
- 第一个参数固定，必须为：self。self指的就是刚刚创建好的实例对象。
- 构造函数通常用来初始化实例对象的实例属性。如上面的代码中`__init__()`就是初始化实例属性：name和score
- 通过“类名（参数列表）”来调用构造函数。调用后，将创建好的对象返回给相应的变量。如`s1 = Student("张三", 88)`
- `__init__()`方法：初始化创建好的对象，初始化指的是：“给实例属性赋值”
- `__new__()`方法：用于创建对象，但我们一般无需重新定义该方法

注：

1.python中的 self 相当于Java中的 this 关键字。python中self必须为构造函数的第一个参数，名字可以任意修改，但一般都叫做 self。

### 实例属性

实例属性是从属于实例对象的属性，也称为“实例变量”。它时使用有如下要点：

1.实例属性一般在 `__init__()`方法中通过如下代码定义：

```python
self.实例属性名 = 初始值
```

2.在本类的其他实例方法中，也是通过 self 进行访问的：

```python
self.实例属性名
```

3.创建实例对象后，通过实例对象访问：

```python 
obj01 = 类名()   #创建对象，调用 __init__() 初始化属性
obj01.实例属性名 = 值   #可以给已有属性赋值，也可以新加属性
```

### 实例方法

实例方法是从属于实例对象的方法，实例方法的定义格式如下：

```python
def 方法名(self[,形参列表])：
	函数体
```

方法的调用格式如下：

```python
对象.方法名([实参列表])
```

**要点**：

- 定义实例方法时，第一个参数必须为 self。和前面一样， self 指当前的实例对象。
- 调用实例方法时，不需要也不能给 self 传参。self 由计时器自动传参。

**函数和方法的区别**：

- 都是用来完成一个功能的语句块，本质一样。
- 方法调用时，通过对象来调用。方法从属于特定实例对象，普通函数没有这个特点。
- 直观上看，方法定义时需要传递 self ，函数不需要。

**其他操作**：

1.`dir(obj)` 可以获得对象的所有属性、方法。

2.`obj.__dict__` 对象的属性字典

3.pass 空语句

4.`isinstance(对象，类型)`判断“对象”是不是“指定类型”

## 类对象

实际上，当解释器执行class语句时就会创建一个类对象。

## 类属性和类方法

### 类属性

类属性是丛属于“类对象”的属性，也称为“类变量”。由于类属性从属于类对象，可以被所有实例对象共享。

类属性的定义方式：

```python
class 类名：
	类变量名 = 初始值
```

在类内或者类的外面，我们可以通过：“类名.类变量名” 来读写。

```python 
class Student:
    
    company = 'sxt'  # 类属性
    count = 0        #类属性
    
    def __init__(self,name,score):
        self.name = name    # 实例属性
        self.score = score
        Student.count += 1
        
    def say_score(self):    # 实例方法
        print("我的公司是：",Student.company)
        print(self.name,"的分数是：", self.score)
```

### 类方法

类方法是从属于“类对象”的方法。类方法通过装饰器 `@classmethod` 来定义，格式如下：

```python
@classmethod
def 类方法名(cls, [,形参列表])：
	函数体
```

要点如下：

​	1.`@classmethod` 必须位于方法上面一行；

​	2.第一个 `cls` 必须有：`cls` 指的就是“类对象”本身；

​	3.调用类方法格式：“类名.类方法名（参数列表）”。参数列表中，不需要也不能给 `cls`传值；

​	4.类方法中访问实例属性和实例方法会导致错误；

​	5.子类继承父类方法，传入 `cls` 是子类对象，而非父类对象；

```python
class Student:
    company = 'SXT'

    @classmethod
    def printCompany(cls):
        print(cls.company)
        
Student.printCompany()
SXT
```

### 静态方法

python中允许定义与“类对象”无关的方法，称为“静态方法”。

“静态方法”和在模块中定义普通函数没有区别，只不过“静态方法”放到了“类的名字空间里面”，需要通过“类调用”。

静态方法通过装饰器 `@staticmethod` 来定义，格式如下：

```python
@staticmethod
def 静态方法名([形参列表])：
	函数体
```

要点如下：

1.`@staticmethod` 必须位于方法上面一行

2.调用静态方法格式：“类名.静态方法名(参数列表)”。

3.静态方法中访问实例属性和实例方法会导致错误。

注意：类方法、静态方法中不能调用实例属性和实例方法

## \__del __  方法（析构函数）和垃圾回收机制

​		`__del__` 方法称为“析构方法”,用于实现对象被销毁时所需的操作。比如：释放对象占用的资源。例如：打开的文件资源、网络连接等。

​		python 实现自动的垃圾回收，当对象没有被引用时（引用计数为0）,由垃圾回收器调用 `__del__`方法。

我们也可以通过 del 语句删除对象，从而保证调用 `__del__` 方法。

系统会自动提供`__del__`方法，一般不需要自定义析构方法。

```python
class Person:

    def __del__(self):
        print("销毁对象：{0}".format(self))

p1 = Person()
p2 = Person()
del p2
print("程序结束")

销毁对象：<__main__.Person object at 0x0000017C93649240>  # 通过del p2销毁
程序结束
销毁对象：<__main__.Person object at 0x0000017C935875F8>  #程序结束自动销毁p1

```

## \__call__方法和可调用对象

定义了 `__call__` 方法的对象，称为“可调用对象”,即该对象可以像函数一样被调用。

## python中方法没有重载

​		python中，方法的参数没有生命类型（调用时确定参数的类型），参数的数量也可以有可变参数控制，因此，python中是没有方法重载的。定义一个方法可以有多种调用方式，相当于实现了其它语言中的方法的重载。

​		如果我们在类体中定义了多个重名的方法，只有最后一个方法有效。

​		建议：不要使用重名的方法！python中方法没有重载。

```python
# python中没有方法的重载，定义多个重名方法只有最后一个有效
class Person:

    def say_hi(self):
        print("hello")

    def say_hi(self,name):
        print("{0},hello".format(name))

p1 = Person()

p1.say_hi() # 不带参，报错
```

### 方法的动态性

python时动态语言，我们可以动态的为类添加新的方法，或者动态的修改类的已有的方法。

### 私有属性和私有方法（实现封装）

​		python对类的成员没有严格的访问控制权限，这与其他面向对象语言有区别，关于私有属性和私有方法，有如下要点：

​		1.通常我们约定，两个下划线开头的属性是私有的（private）。其他为公共的（public）。

​		2.类内部可以访问私有属性（方法）

​		3.类内部不能直接访问私有属性（方法）

​		4.类内部可以通过“\__类名 __私有属性（方法）名” 访问私有属性（方法）

【注】方法本质上也是属性！只不过是可以通过（）执行而已。

## @property 装饰器

@property 可以将一个方法的调用方式编程“属性调用”。下面是一个简单示例：

```python
class Emloyee:

    def __init__(self, name, salary):
        self.__name = name
        self.__salary = salary

'''
    def get_salary(self):
        return self.__salary

    def set_salary(self, salary):
        if 1000 < salary < 50000:
            self.__salary = salary
        else:
            print("薪水在1000--50000这个范围")
'''


    @property
    def salary(self):
        return self.__salary

    @salary.setter
    def salary(self, salary):
        if 1000 < salary < 50000:
            self.__salary = salary
        else:
            print("薪水在1000--50000这个范围")

```

# 面相对象的三大特征介绍

### 封装（隐藏）

​		隐藏对象的属性和实现细节，只对外提供必要的方法，相当于将“细节封装起来”，只对外暴露“相关调用方法”。

​		通过前面学习的“私有属性、私有方法”的方式，实现“封装”。python追求简洁的语法，没有严格的语法级别的“访问控制符”，更多的是依靠程序员自觉实现。

###继承

​		继承可以让子类具有父类的特性，提高了代码的重用性。

​		从设计上是一种增量进化，原有父类设计不变的情况下，可以增加新的功能，或者改进已有的算法。

### 多态

​		多态是指同一个方法调用由于对象不同会产生不同的行为。

## 继承

​		继承是面向对象程序设计的重要特征，也是实现“代码复用”的重要手段。

​		如果有一个新类继承自一个设计好的类，就直接具备了已有类的特征，就大大降低了工作难度。已有的类我们称为“父类或基类”，新的类我们称为“子类或者派生类”。

### 语法格式

​		python支持多重继承，一个子类可以继承多个父类。继承的语法格式如下：

```python
class 子类类名(父类1[,父类2， ...]):
    类体
```

​		如果在类定义中没有指定父类，则默认父类是 object 类，也就是说，object 是所有类的父类，里面定义了一些所有类共有的默认实现，如：`__new__()`。

​		定义子类时，必须在其构造函数中调用父类的构造函数。调用格式如下：

```python
父类名.__init__(self,参数列表)
```

```python
class Person:

    def __init__(self, name, age):
        self.name = name
        self.__age = age # 私有属性

    def say_age(self):
        print("年龄，年龄，我也不知道")


class Student(Person):

    def __init__(self, name, age, score):
        Person.__init__(self, name, age) # 必须显式的调用父类初始化方法，不然解释器不回去调用
        self.score = score


s1 = Student("张三", 20, 90)
s1.say_age()
print(s1.name)
# print(s1.age)  # 子类虽然继承了父类的私有属性，但是不能直接用
print(dir(s1))  # 查看属性
print(s1._Person__age)  # 调用父类的私有方法
```

### 类成员的继承和重写

1.成员继承：子类继承了父类除构造方法之外的所有成员。

2.方法重写：子类可以重新定义父类中的方法，这样就会覆盖父类的方法，也成为“重写”。

### 查看类的继承层级结构

通过类的方法 `mro()` 或者类的属性 `__mro__` 可以输出这个类的继承层次结构。

```python
class A:
    pass
class B(A):
    pass
class C(B):
    pass

print(C.mro())
[<class '__main__.C'>, <class '__main__.B'>, <class '__main__.A'>, <class 'object'>]

```

### object 根类

​		object 类是所有类的父类。因此所有的类都是 object 类的属性和方法。我们显然有必要深入研究一下 object 类的结构。

#### dir() 查看对象属性

### 重写 \__str__() 方法

​		object 有一个 `__str__()` 方法，用于返回一个对于“对象的描述”，对应于内置函数 `str()` 经常用于print() 方法，帮助我们查看对象的信息，`__str__()` 可以重写。

```python
class Person:

    def __init__(self, name):
        self.name = name
    def __str__(self):
        return "名字是：{0}".format(self.name)
    
p = Person("张三")
print(p)

<__main__.Person object at 0x000002381B2F75F8>  # object默认
名字是：张三   # 重写__str__() 方法
```

### 多重继承

​		python支持多重继承，一个子类可以有多个“直接父类”。这样，就具备了“多个父类” 的特点。但是这样会被“类的整体层次”搞得异常复杂，尽量避免使用。

### MRO() 

​		python 支持多重继承，如果父类中有相同名字的方法，在子类没有指定父类名时，解释器将“从左向右”。

MRO(Method Resolution Order)：方法解析顺序。我们可以通过 mro() 方法获得“类的层次机构”，方法解析顺序也是按照这个“类的层次结构”寻找的。

### super() 获得父类定义

在子类中，如果想要获得父类的方法时，我们可以通过 super() 来做。

super() 代表父类的定义，不是父类对象。

```python
class A:
    def say(self):
        print("A:", self)

class B(A):

    def say(self):
        # A.say(self)
        super().say()
        print("B:", self)


B().say()
A: <__main__.B object at 0x000001E725169438>
B: <__main__.B object at 0x000001E725169438>
```

## 多态

多态（polymorphism）是指同一个方法调用由于对象不同可能会产生不同的行为。

使用多态要注意以下两点：

1.多态是方法的多态，属性没有多态。

2.多态的存在有2个必要条件：继承、方法重写

```python
class Man:
    def eat(self):
        print("饿了，吃饭了")


class Chinese(Man):
    def eat(self):
        print("中国人用筷子吃饭")

class English(Man):
    def eat(self):
        print("英国人用叉子吃饭")


class Indian(Man):
    def eat(self):
        print("印度人用右手吃饭")


def manEat(m):
    if isinstance(m, Man): # 多态，一个方法调用，根据对象不同调用不同的方法
        m.eat()
    else:
        print("不能吃饭")

manEat(Chinese())
manEat(English())
中国人用筷子吃饭
英国人用叉子吃饭
```

### 特殊方法和运算符重载

#### 常见的特殊方法统计如下：

- `__init__` 构造方法 
- `__del__`   析构方法
- `__repr__`,`__str__` 打印、转换
- `__call__`  函数调用
- `__getattr__` 点号运算  例如： a.xxx
- `__setattr__`  属性赋值  例如：a.xxx = value
- `__getitem__` 索引运算  例如：a[key]
- `__setitem__`  索引赋值  例如：a[key] = value
- `__len__`  长度 例如：len(a)

#### 运算符对应的方法

- \+   :  `__add__`  :  加法
- \-    :  `__sub__`   :  减法
- \<、<=、== ：`__lt__`、`__le__`、`__eq__`  ：比较运算符
- \>、>=、!=   :  `__gt__`、`__ge__`、`__ne__` ：比较运算符
- | 、^、&  ：`__or__`、`__xor__`、`__and__`   :  或、异或、与
- << 、>> ：`__lshift__`、`__rshift__`  :  左移、右移
- *、/、%、//  ：`__mul__`、`__truediv__`、`__mod__`、`__floordiv__`  :  乘，浮点除，模运算（取余）、整数除
- \**   :  `__pow__`   :  指数运算

### 特殊属性

`obj.__dict__`  : 对象的属性字典

`obj.__class__`: 对象所属的类

`class.__bases__`  :  类的基类元组（多继承）

`class.__base__` ：类的基类

`class.__mro__`：类的层次结构

`class.__subclasses__()` :子类列表

## 组合

​		“is-a” 关系，我们可以使用“继承”。从而实现子类拥有的父类的方法和属性。“is-a" 关系指的是类似于这样的关系：狗是动物，dog is animal 。狗类就应该继承动物类。

​		”has-a“ 关系，我们可以使用”组合“,也能实现一个类拥有另一个类的方法和属性。

